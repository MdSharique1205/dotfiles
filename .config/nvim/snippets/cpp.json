{
	"Ordred Set":{
		"prefix": ["ordered_set"],
		"body": ["// Ordered Set",
						"template <typename T>",
						"using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
						""
			],
		"description": "Policy Based Data Structure: Ordered Set"
	},
	"INT Min Heap":{
		"prefix": ["min_heap_int"],
		"body": ["// Min heap", "priority_queue<int, vector<int>, greater<int>> mh;"],
		"description": "INT Min Heap"
	},
	"Templated Min Heap":{
		"prefix": ["min_heap_temp"],
		"body": ["// Min heap", "priority_queue<${1}, vector<${1}>, greater<${1}>> mh;"],
		"description": "Templated Min Heap"
	},
	"Union Find": {
  	"prefix": ["union_find", "uf"],
  "body": [
    "struct uf{",
    "  vector<int> link, size;",
    "  int components = -1;",
    "  uf(int n)",
    "  {",
    "    components = n;",
    "    link = vector<int>(n+1);",
    "    size = vector<int>(n+1, 1);",
    "    for(int i=1;i<=n;i++)",
    "      link[i] = i;",
    "  }",
    "  int find(int x)",
    "  {",
    "    while(link[x] != x)",
    "      x = link[x];",
    "    return x;",
    "  }",
    "  void unite(int a, int b)",
    "  {",
    "    a = find(a);",
    "    b = find(b);",
    "    if(same(a,b))",
    "      return;",
    " ",
    "    if(size[a]>size[b])",
    "      swap(a,b);",
    " ",
    "    link[a] = b;",
    "    size[b] += size[a];",
    "    size[a] = 0;",
    "    components--;",
    "  }",
    "  bool same(int a, int b)",
    "  {",
    "    return find(a) == find(b);",
    "  }",
    "};",
    ""
  ],
  	"description": "Union Find"
	},
		"Segment Tree": {
  	"prefix": "segment_tree",
  	"body": [
    	"template <typename T>",
    	"",
    	"// Segment Tree",
    	"struct segment_tree {",
    	"  int size;",
    	"  int n;",
    	"  T ans_init;",
    	"  vector<T> v;",
    	"",
    	"  segment_tree(int _n, T init_val) {",
    	"    n = _n;",
    	"    size = 1;",
    	"    ans_init = init_val;",
    	"",
    	"    while (size < 2 * n)",
    	"      size = size << 1;",
    	"",
    	"    v = vector<T>(size);",
    	"  }",
    	"",
    	"  segment_tree(int _n, T init_val, vector<T> &_v) {",
    	"    n = _n;",
    	"    size = 1;",
    	"    ans_init = init_val;",
    	"",
    	"    while (size < 2 * n)",
    	"      size = size << 1;",
    	"",
    	"    v = vector<T>(size);",
    	"    for (int i = n; i <= 2 * n - 1; i++)",
    	"      v[i] = _v[i - n];",
    	"  }",
    	"",
    	"  void build() {",
    	"    for (int i = n - 1; i >= 1; i--)",
    	"      v[i] = __fun(v[2 * i], v[2 * i + 1]);",
    	"  }",
    	"",
    	"  void take_input(vector<int> &v) {",
    	"    for (int i = n; i <= 2 * n - 1; i++)",
    	"      cin >> v[i];",
    	"    build();",
    	"  }",
    	"  // idx is one-indexed",
    	"  void update(int idx, T val) {",
    	"    int index = idx + n - 1;",
    	"    v[index] = val;",
    	"    index /= 2;",
    	"    while (index >= 1) {",
    	"      v[index] = __fun(v[2 * index], v[2 * index + 1]);",
    	"      index /= 2;",
    	"    }",
    	"  }",
    	"",
    	"  // l and r are one-indexed, and both are inclusive",
    	"  T range(int l, int r) {",
    	"    T ans = ans_init;",
    	"    l += n - 1;",
    	"    r += n - 1;",
    	"    while (l <= r) {",
    	"      if (l & 1)",
    	"        ans = __fun(ans, v[l++]);",
    	"      if (!(r & 1))",
    	"        ans = __fun(ans, v[r--]);",
    	"      l /= 2;",
    	"      r /= 2;",
    	"    }",
    	"    return ans;",
    	"  }",
    	"",
    	"  // Internal modules",
    	"  T __fun(T a, T b) {",
    	"    T ret;",
    	"    // Set here accordingly",
    	"    ret = a + b;",
    	"    // ret = min(a,b);",
    	"    // ret = max(a,b);",
    	"    // ret = a^b;",
    	"    return ret;",
    	"  }",
    	"};"
  	],
  	"description": "Segment Tree"
	},
	"Component Graph": {
  	"prefix": "comp_graph",
  	"body": [
    	"struct comp_graph",
    	"{",
    	"  int n, t;",
    	"  vector<bool> node_with_edge;",
    	"  vector<int> node_to_comp;",
    	"  vector<vector<int>> comp_nodes;",
    	"  vector<set<int>> adj;",
    	"",
    	"  void dfs_one(int node, vector<int> &node_to_comp, set<pi> &p_time, vector<vector<int>> &adj)",
    	"  {",
    	"    if(node_to_comp[node])",
    	"      return;",
    	"    t++;",
    	"    node_to_comp[node] = -1;",
    	"    for(auto i:adj[node])",
    	"      dfs_one(i, node_to_comp, p_time, adj);",
    	"    t++;",
    	"    p_time.insert({-1*t, node});",
    	"  }",
    	"",
    	"  void dfs_one(int node, vector<int> &node_to_comp, set<pi> &p_time, vector<set<int>> &adj)",
    	"  {",
    	"    if(node_to_comp[node])",
    	"      return;",
    	"    t++;",
    	"    node_to_comp[node] = -1;",
    	"    for(auto i:adj[node])",
    	"      dfs_one(i, node_to_comp, p_time, adj);",
    	"    t++;",
    	"    p_time.insert({-1*t, node});",
    	"  }",
    	"",
    	"  void dfs_two(int node, vector<int>&node_to_comp, vector<vector<int>>&rev_adj)",
    	"  {",
    	"    if(node_to_comp[node]!=-1) ",
    	"      return;",
    	"    node_to_comp[node] = t;",
    	"    for(auto &i:rev_adj[node])",
    	"      dfs_two(i, node_to_comp, rev_adj);",
    	"  }",
    	"  void print_graph()",
    	"  {",
    	"    cout<<\"size: \"<<n<<'\\n';",
    	"    cout<<\"adj-list:\\n\";",
    	"    for(int i=1;i<=n;i++)",
    	"    {",
    	"      cout<<i<<\": \";",
    	"      for(auto &j: adj[i])",
    	"        cout<<j<<' ';",
    	"      cout<<'\\n';",
    	"    }",
    	"    cout<<\"node_to_components: \\n\";",
    	"    for(int i=1;i<=n;i++)",
    	"    {",
    	"      cout<<i<<\": \";",
    	"      for(auto &j:comp_nodes[i])",
    	"        cout<<j<<' ';",
    	"      cout<<'\\n';",
    	"    }",
    	"  }",
    	"  comp_graph(int n1, vector<set<int>> &adj_list, bool eulerian=false)",
    	"  {",
    	"    set<pi> p_time;",
    	"    node_to_comp = vector<int>(n1+1);",
    	"    node_with_edge = vector<bool> (n1+1);",
    	"    vector<vector<int>> rev_adj(n1+1);",
    	"    for(int i=1;i<=n1;i++)",
    	"      for(auto &j:adj_list[i])",
    	"      {",
    	"        rev_adj[j].PB(i);",
    	"        node_with_edge[i] = true;",
    	"        node_with_edge[j] = true;",
    	"      }",
    	"    // Kosaraju's Algorithm",
    	"    // 1st Pass",
    	"    t = 0;",
    	"    for(int i=1;i<=n1;i++)",
    	"      if((!eulerian || node_with_edge[i]) && !node_to_comp[i])",
    	"        dfs_one(i, node_to_comp, p_time, adj_list);",
    	"",
    	"    // 2nd Pass",
    	"    t = 1;",
    	"    for(auto &i:p_time)",
    	"      if(node_to_comp[i.S]==-1)",
    	"      {",
    	"        dfs_two(i.S, node_to_comp, rev_adj);",
    	"        t++;",
    	"      }",
    	"    // Number of node_to_components",
    	"    n = t-1;",
    	"    // comp_nodes",
    	"    comp_nodes = vector<vector<int>>(n+1);",
    	"    for(int i=1;i<=n1;i++)",
    	"      comp_nodes[node_to_comp[i]].PB(i);",
    	"    // creating scc graph",
    	"    adj = vector<set<int>>(n+1);",
    	"    for(int i=1;i<=n1;i++)",
    	"      for(auto &j:adj_list[i])",
    	"        if(node_to_comp[i]!=node_to_comp[j])",
    	"          adj[node_to_comp[i]].insert(node_to_comp[j]);",
    	"  }",
    	"  comp_graph(int n1, vector<vector<int>> &adj_list, bool eulerian=false)",
    	"  {",
    	"    set<pi> p_time;",
    	"    node_with_edge = vector<bool> (n1+1);",
    	"    node_to_comp = vector<int>(n1+1);",
    	"    vector<vector<int>> rev_adj(n1+1);",
    	"    for(int i=1;i<=n1;i++)",
    	"      for(auto &j:adj_list[i])",
    	"      {",
    	"        rev_adj[j].PB(i);",
    	"        node_with_edge[i] = true;",
    	"        node_with_edge[j] = true;",
    	"      }",
    	"    // Kosaraju's Algorithm",
    	"    // 1st Pass",
    	"    t = 0;",
    	"    for(int i=1;i<=n1;i++)",
    	"      if((!eulerian || node_with_edge[i]) && !node_to_comp[i])",
    	"        dfs_one(i, node_to_comp, p_time, adj_list);",
    	"",
    	"    // 2nd Pass",
    	"    t = 1;",
    	"    for(auto &i:p_time)",
    	"      if(node_to_comp[i.S]==-1)",
    	"      {",
    	"        dfs_two(i.S, node_to_comp, rev_adj);",
    	"        t++;",
    	"      }",
    	"    // Number of node_to_components",
    	"    n = t-1;",
    	"    // comp_nodes",
    	"    comp_nodes = vector<vector<int>>(n+1);",
    	"    for(int i=1;i<=n1;i++)",
    	"      comp_nodes[node_to_comp[i]].PB(i);",
    	"    // creating scc graph",
    	"    adj = vector<set<int>>(n+1);",
    	"    for(int i=1;i<=n1;i++)",
    	"      for(auto &j:adj_list[i])",
    	"        if(node_to_comp[i]!=node_to_comp[j])",
    	"          adj[node_to_comp[i]].insert(node_to_comp[j]);",
    	"  }",
    	"};"
  	],
  	"description": "Component Graph"
	},
	"Flow Graph": {
  "prefix": "flow_graph",
  "body": [
    	" struct flow_graph {",
    	"  int n, m;",
    	"  ll t, max_flow;",
    	"  vector<pi> min_cuts;",
    	"  vector<bool> visited;",
    	"  vector<set<int>> adj;",
    	"  vector<vector<ll>> wadj;",
    	"  flow_graph(int n1, int m1, vector<vector<pi>> &_adj) {",
    	"    max_flow = 0;",
    	"    t = 0;",
    	"    n = n1;",
    	"    m = m1;",
    	"    visited = vector<bool>(n + 1);",
    	"    adj = vector<set<int>>(n + 1);",
    	"    wadj = vector<vector<ll>>(n + 1, vector<ll>(n + 1));",
    	"",
    	"    for (int i = 1; i <= n; i++)",
    	"      for (auto &j : _adj[i]) {",
    	"        adj[i].insert(j.F);",
    	"        adj[j.F].insert(i);",
    	"        wadj[i][j.F] += j.S;",
    	"        t += j.S;",
    	"      }",
    	"",
    	"    __solve();",
    	"    get_cuts();",
    	"  }",
    	"",
    	"  bool dfs(int node, ll &mn) {",
    	"    if (visited[node])",
    	"      return false;",
    	"    if (node == n)",
    	"      return true;",
    	"",
    	"    visited[node] = true;",
    	"",
    	"    ll k;",
    	"    for (auto &i : adj[node]) {",
    	"      k = mn;",
    	"      if (wadj[node][i] && wadj[node][i] >= t) {",
    	"        k = min(k, wadj[node][i]);",
    	"        if (dfs(i, k)) {",
    	"          mn = k;",
    	"          wadj[node][i] -= k;",
    	"          wadj[i][node] += k;",
    	"          if (node == 1) {",
    	"            max_flow += k;",
    	"          }",
    	"          return true;",
    	"        }",
    	"      }",
    	"    }",
    	"    return false;",
    	"  }",
    	"",
    	" void cut_dfs(int node) {",
    	"    if (visited[node])",
    	"      return;",
    	"    visited[node] = true;",
    	"    for (auto &i : adj[node])",
    	"      if (wadj[node][i])",
    	"        cut_dfs(i);",
    	"  }",
    	"",
    	"  void get_cuts() {",
    	"    for (int i = 1; i <= n; i++)",
    	"      visited[i] = false;",
    	"    cut_dfs(1);",
    	"    for (int i = 1; i <= n; i++)",
    	"      if (visited[i])",
    	"        for (auto &j : adj[i])",
    	"          if (!visited[j] && !wadj[i][j])",
    	"            min_cuts.PB({i, j});",
    	"  }",
    	"",
    	"  void __solve() {",
    	"    ll mn;",
    	"    while (t != 0) {",
    	"      for (int i = 1; i <= n; i++)",
    	"        visited[i] = false;",
    	"      mn = LLONG_MAX;",
    	"      if (!dfs(1, mn))",
    	"        t /= 2;",
    	"    }",
    	"  }",
    	"};"
  	],
  	"description": "Flow Graph"
	},
	"Tree with LCA": {
  "prefix": "tree_lca",
  "body": [
    	"struct Tree {",
    	"  int n;",
    	"  int root;",
    	"  int log2_n;",
    	"  vector<int> depth;",
    	"  vector<int> parent;",
    	"  vector<vector<int>> adj;",
    	"  vector<vector<int>> dp;",
    	"  Tree(int _n, int _root = 1) {",
    	"    n = _n;",
    	"    root = _root;",
    	"    log2_n = 0;",
    	"    while ((1 << (log2_n + 1)) <= n)",
    	"      log2_n++;",
    	"",
    	"    depth = vector<int>(n + 1);",
    	"    parent = vector<int>(n + 1);",
    	"    adj = vector<vector<int>>(n + 1);",
    	"    dp = vector<vector<int>>(n + 1, vector<int>(log2_n + 1, -1));",
    	"  }",
    	"",
    	"  void build() {",
    	"    __get_depth_and_parent(root, -1);",
    	"    __populate_k_ances_dp();",
    	"  }",
    	"",
    	"  void add_edge(int a, int b) {",
    	"    adj[a].PB(b);",
    	"    adj[b].PB(a);",
    	"  }",
    	"",
    	"  int kth_ances(int node, int k) {",
    	"    for (int i = 0; (1 << i) <= k && node; i++)",
    	"      if ((1 << i) & k)",
    	"        node = dp[node][i];",
    	"    return node;",
    	"  }",
    	"  int lca(int a, int b) {",
    	"    if (depth[a] < depth[b])",
    	"      swap(a, b);",
    	"    a = kth_ances(a, depth[a] - depth[b]);",
    	"    if (a == b)",
    	"      return a;",
    	"    for (int j = log2_n; j >= 0; j--) {",
    	"      if (dp[a][j] == -1 || dp[b][j] == -1)",
    	"        continue;",
    	"      if (dp[a][j] != dp[b][j]) {",
    	"        a = dp[a][j];",
    	"        b = dp[b][j];",
    	"      }",
    	"    }",
    	"    return dp[a][0];",
    	"  }",
    	"",
    	"  // Internal modules",
    	"  void __populate_k_ances_dp() {",
    	"    for (int i = 1; i <= n; i++)",
    	"      dp[i][0] = parent[i];",
    	"    for (int j = 1; j <= log2_n; j++)",
    	"      for (int i = 1; i <= n; i++)",
    	"        if (dp[i][j - 1] != -1)",
    	"          dp[i][j] = dp[dp[i][j - 1]][j - 1];",
    	"  }",
    	"  void __get_depth_and_parent(int node, int _parent) {",
    	"    parent[node] = _parent;",
    	"    for (auto &i : adj[node]) {",
    	"      if (i == _parent)",
    	"        continue;",
    	"      depth[i] = depth[node] + 1;",
    	"      __get_depth_and_parent(i, node);",
    	"    }",
    	"  }",
    	"};"
  	],
  	"description": "Tree with LCA"
	},
		"Tree for Subtree queries": {
  	"prefix": "subtree_queries",
  	"body": [
    	"template <typename T>",
    	"",
    	"// Segment Tree",
    	"struct segment_tree {",
    	"  int size;",
    	"  int n;",
    	"  T ans_init;",
    	"  vector<T> v;",
    	"",
    	"  segment_tree(int _n, T init_val) {",
    	"    n = _n;",
    	"    size = 1;",
    	"    ans_init = init_val;",
    	"",
    	"    while (size < 2 * n)",
    	"      size = size << 1;",
    	"",
    	"    v = vector<T>(size);",
    	"  }",
    	"",
    	"  segment_tree(int _n, T init_val, vector<T> &_v) {",
    	"    n = _n;",
    	"    size = 1;",
    	"    ans_init = init_val;",
    	"",
    	"    while (size < 2 * n)",
    	"      size = size << 1;",
    	"",
    	"    v = vector<T>(size);",
    	"    for (int i = n; i <= 2 * n - 1; i++)",
    	"      v[i] = _v[i - n];",
    	"  }",
    	"",
    	"  void build() {",
    	"    for (int i = n - 1; i >= 1; i--)",
    	"      v[i] = __fun(v[2 * i], v[2 * i + 1]);",
    	"  }",
    	"",
    	"  void take_input(vector<int> &v) {",
    	"    for (int i = n; i <= 2 * n - 1; i++)",
    	"      cin >> v[i];",
    	"    build();",
    	"  }",
    	"  // idx is one-indexed",
    	"  void update(int idx, T val) {",
    	"    int index = idx + n - 1;",
    	"    v[index] = val;",
    	"    index /= 2;",
    	"    while (index >= 1) {",
    	"      v[index] = __fun(v[2 * index], v[2 * index + 1]);",
    	"      index /= 2;",
    	"    }",
    	"  }",
    	"",
    	"  // l and r are one-indexed, and both are inclusive",
    	"  T range(int l, int r) {",
    	"    T ans = ans_init;",
    	"    l += n - 1;",
    	"    r += n - 1;",
    	"    while (l <= r) {",
    	"      if (l & 1)",
    	"        ans = __fun(ans, v[l++]);",
    	"      if (!(r & 1))",
    	"        ans = __fun(ans, v[r--]);",
    	"      l /= 2;",
    	"      r /= 2;",
    	"    }",
    	"    return ans;",
    	"  }",
    	"",
    	"  // Internal modules",
    	"  T __fun(T a, T b) {",
    	"    T ret;",
    	"    // Set here accordingly",
    	"    ret = a + b;",
    	"    // ret = min(a,b);",
    	"    // ret = max(a,b);",
    	"    // ret = a^b;",
    	"    return ret;",
    	"  }",
    	"};",
    	"",
    	"struct Tree {",
    	"  int n;",
    	"  int root;",
    	"  vector<ll> value;",
    	"  vector<int> euler_path;",
    	"  vector<int> node_order;",
    	"  vector<int> subtree_size;",
    	"  vector<vector<int>> adj;",
    	"  struct segment_tree<ll> *s;",
    	"",
    	"  Tree(int _n, int _root = 1) {",
    	"    n = _n;",
    	"    root = _root;",
    	"    value = vector<ll>(n + 1);",
    	"    euler_path = vector<int>(n + 1);",
    	"    node_order = vector<int>(n + 1);",
    	"    subtree_size = vector<int>(n + 1, 1);",
    	"    adj = vector<vector<int>>(n + 1);",
    	"  }",
    	"",
    	"  void build() {",
    	"    __get_euler_path_and_subtree_size();",
    	"    vector<ll> v(n);",
    	"    for (int i = 0; i < n; i++) {",
    	"      v[i] = value[euler_path[i]];",
    	"    }",
    	"    s = new segment_tree<ll>(n, 0, v);",
    	"    s->build();",
    	"  }",
    	"",
    	"  void update(int idx, int val) { s->update(node_order[idx], val); }",
    	"",
    	"  ll query(int node) {",
    	"    return s->range(node_order[node],",
    	"                    node_order[node] + subtree_size[node] - 1);",
    	"  }",
    	"",
    	"  void take_input() {",
    	"    for (int i = 1; i <= n; i++)",
    	"      cin >> value[i];",
    	"  }",
    	"",
    	"  void add_edge(int a, int b) {",
    	"    adj[a].PB(b);",
    	"    adj[b].PB(a);",
    	"  }",
    	"",
    	"  // Internal modules",
    	"  void __get_euler_path_and_subtree_size() {",
    	"    int k = 0;",
    	"    __dfs(root, -1, k);",
    	"",
    	"    for (int i = 0; i < n; i++)",
    	"      node_order[euler_path[i]] = i + 1;",
    	"  }",
    	"  void __dfs(int node, int parent, int &k) {",
    	"    euler_path[k++] = node;",
    	"    for (auto &i : adj[node]) {",
    	"      if (i == parent)",
    	"        continue;",
    	"      __dfs(i, node, k);",
    	"      subtree_size[node] += subtree_size[i];",
    	"    }",
    	"  }",
    	"};"
  	],
  	"description": "Tree for Subtree queries"
	},
		"Modulo Operations": {
  	"prefix": "mod",
  	"body": [
    	"const int MODULO = 1e9 + 7;",
    	"",
    	"ll __mod(ll x, ll y) {",
    	"  ll m = x % y;",
    	"  if (m < 0)",
    	"    m += y;",
    	"  return m;",
    	"}",
    	"",
    	"ll mod_pow(ll x, ll n, ll m = MODULO) {",
    	"  if (n == 0)",
    	"    return __mod(1, m);",
    	"  ll t = mod_pow(x, n / 2, m);",
    	"  ll ret = __mod((t * t), m);",
    	"  if (n & 1)",
    	"    ret = __mod((ret * x), m);",
    	"  return ret;",
    	"}",
    	"",
    	"ll mmi(ll x, ll m = MODULO) { return mod_pow(x, m - 2, m); }",
    	"ll mod_p(ll a, ll b, ll m = MODULO) { return __mod((a * b), m); }",
    	"ll mod_d(ll a, ll b, ll m = MODULO) { return __mod((a * mmi(b, m)), m); }",
    	"ll mod_a(ll a, ll b, ll m = MODULO) { return __mod((a + b), m); }",
    	"ll mod_s(ll a, ll b, ll m = MODULO) { return __mod((a - b), m); }",
    	""
  	],
  	"description": "Modulo Operations"
	}
}
