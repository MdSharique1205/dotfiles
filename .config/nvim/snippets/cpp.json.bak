{
	"ordered_set":{
		"prefix": ["ordered_set"],
		"body": ["// Ordered Set",
						"#include <ext/pb_ds/assoc_container.hpp>",
						"using namespace std;",
						"using namespace __gnu_pbds;",
						"template <typename T>",
						"using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
						""
			],
		"description": "Policy Based Data Structure: Ordered Set"
	},
	"segment_tree":{
		"prefix": ["segment_tree"],
		"body": ["// Segment Tree",
						" struct segment_tree",
						"{",
						"  vector<T> v;",
						"  int size=0, arr_len=0;",
						"  T ans_init;\n",
						"  segment_tree(int n, T init_val)",
						"  {",
						"    arr_len = n;",
						"    ans_init = init_val;",
						"    int i=0;",
						"    while((1<<i++) < 2*n);",
						"    size = 1<<i;",
						"    v = vector<T>(size);",
						"  }\n",
						"  T fun(T a, T b)",
						"  {",
						"    T ret;",
						"    // Set here accordingly",
						"    ret = a+b;",
						"    // ret = min(a,b);",
						"    // ret = max(a,b);",
						"    // ret = a^b;",
						"    return ret; ",
						"  }\n",
						"  void build()",
						"  {",
						"    for(int i=arr_len-1;i>=1;i--)",
						"      v[i] = fun(v[2*i], v[2*i+1]);",
						"  }\n",
						"  void print_tree()",
						"  {",
						"    cout<<"segment tree values:",
						"";",
						"    for(int i=0;i<size;i++)",
						"      cout<<v[i]<<' ';",
						"    cout<<'",
						"';",
						"  }\n",
						"  void take_input()",
						"  {",
						"    for(int i=arr_len ; i <= 2*arr_len-1 ; i++)",
						"      cin>>v[i];",
						"    build();",
						"  }\n",
						"  // idx is one-indexed",
						"  void update(int idx, T val)",
						"  {",
						"    int index = idx+arr_len-1;",
						"    v[index] = val;",
						"    index/=2;",
						"    while(index>=1)",
						"    {",
						"      v[index] = fun(v[2*index], v[2*index+1]);",
						"      index/=2;",
						"    }",
						"  }\n",
						"  // l and r are one-indexed, and both are inclusive",
						"  T range(int l, int r)",
						"  {",
						"    T ans=ans_init;",
						"    l += arr_len-1;",
						"    r += arr_len-1;",
						"    while(l<=r) ",
						"    {",
						"      if(l&1) ans = fun(ans, v[l++]);",
						"      if(!(r&1)) ans = fun(ans, v[r--]);",
						"      l/=2;",
						"      r/=2;",
						"    }",
						"    return ans;",
						"  }",
						"};n",
						""
		],
		"description": "Segment Tree"
	},
	"min_heap_int":{
		"prefix": ["min_heap_int"],
		"body": ["// Min heap", "priority_queue<int, vector<int>, greater<int>> mh;"],
		"description": "Min Heap INT"
	},
	"min_heap_temp":{
		"prefix": ["min_heap_temp"],
		"body": ["// Min heap", "priority_queue<${1}, vector<${1}>, greater<${1}>> mh;"],
		"description": "Templated Min Heap"
	},
	"modulo":{
		"prefix": ["modulo"],
		"body": ["template<typename T>", "T modulo(T x, T y)", "{", " T m = x%y;", "  if(m<0)", "    m+=y;", "  return m;", "}"],
		"description": "Templated Modulo"
	}
}
